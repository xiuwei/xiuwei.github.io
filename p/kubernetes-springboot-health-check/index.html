<!doctype html><html lang=zh-Hans dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="在 Kubernetes 环境中部署 Spring Boot 微服务，并配置和健康检查，以确保微服务的可靠性和稳定性"><title>实战指南：在 Kubernetes 上部署 Spring Boot 微服务并实施健康检查</title>
<link rel=canonical href=https://xiuwei.github.io/p/kubernetes-springboot-health-check/><link rel=stylesheet href=/scss/style.min.8e60baf4cd3fc55968717a6e39762f4d28ed7ef6007566b6c7970ad0fe907198.css><meta property='og:title' content="实战指南：在 Kubernetes 上部署 Spring Boot 微服务并实施健康检查"><meta property='og:description' content="在 Kubernetes 环境中部署 Spring Boot 微服务，并配置和健康检查，以确保微服务的可靠性和稳定性"><meta property='og:url' content='https://xiuwei.github.io/p/kubernetes-springboot-health-check/'><meta property='og:site_name' content='哈皮的自言自语'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='Cloud Native'><meta property='article:tag' content='Kubernetes'><meta property='article:tag' content='Spring Boot'><meta property='article:tag' content='健康检查'><meta property='article:published_time' content='2024-04-20T21:00:00+00:00'><meta property='article:modified_time' content='2024-04-20T21:00:00+00:00'><meta property='og:image' content='https://xiuwei.github.io/p/kubernetes-springboot-health-check/cover.jpg'><meta name=twitter:site content="@@Willie_Lau"><meta name=twitter:creator content="@@Willie_Lau"><meta name=twitter:title content="实战指南：在 Kubernetes 上部署 Spring Boot 微服务并实施健康检查"><meta name=twitter:description content="在 Kubernetes 环境中部署 Spring Boot 微服务，并配置和健康检查，以确保微服务的可靠性和稳定性"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content='https://xiuwei.github.io/p/kubernetes-springboot-health-check/cover.jpg'><link rel="shortcut icon" href=/favicon.ico></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_huc21dbe1ce4b866464592b14304df5a25_40367_300x0_resize_q75_box.jpeg width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>🍥</span></figure><div class=site-meta><h1 class=site-name><a href=/>哈皮的自言自语</a></h1><h2 class=site-description>Entities should not be multiplied unnecessarily.</h2></div></header><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>主页</span></a></li><li><a href=/archives/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>归档</span></a></li><li><a href=/search/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>检索</span></a></li><li><a href=/about/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>About</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>暗色模式</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#1-引言>1. 引言</a></li><li><a href=#2-原理>2. 原理</a><ol><li><a href=#21-kubernetes健康检查机制>2.1 Kubernetes健康检查机制</a><ol><li><a href=#211-探针类型>2.1.1 探针类型</a></li><li><a href=#212-探针结果>2.1.2 探针结果</a></li><li><a href=#213-探针检查机制>2.1.3 探针检查机制</a></li></ol></li><li><a href=#22-spring-boot对kubernetes容器探针的支持>2.2 Spring Boot对Kubernetes容器探针的支持</a><ol><li><a href=#221-spring-boot-如何识别k8s环境>2.2.1 Spring Boot 如何识别k8s环境</a></li><li><a href=#222-spring-boot-与k8s容器探针的结合>2.2.2 Spring Boot 与k8s容器探针的结合</a></li><li><a href=#223-spring-boot-生命周期与探测状态>2.2.3 Spring Boot 生命周期与探测状态</a></li></ol></li></ol></li><li><a href=#3-准备工作>3. 准备工作</a></li><li><a href=#4-在-kubernetes-中部署-spring-boot-微服务>4. 在 Kubernetes 中部署 Spring Boot 微服务</a></li><li><a href=#5-配置健康检查>5. 配置健康检查</a></li><li><a href=#6-验证>6. 验证</a></li><li><a href=#7-总结>7. 总结</a></li><li><a href=#参考资料>参考资料</a></li></ol></nav></div></section></aside><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/p/kubernetes-springboot-health-check/><img src=/p/kubernetes-springboot-health-check/cover_hu5459c0360c2b0cb7a147d2df0eb350ca_1001946_800x0_resize_q75_box.jpg srcset="/p/kubernetes-springboot-health-check/cover_hu5459c0360c2b0cb7a147d2df0eb350ca_1001946_800x0_resize_q75_box.jpg 800w, /p/kubernetes-springboot-health-check/cover_hu5459c0360c2b0cb7a147d2df0eb350ca_1001946_1600x0_resize_q75_box.jpg 1600w" width=800 height=450 loading=lazy alt="Featured image of post 实战指南：在 Kubernetes 上部署 Spring Boot 微服务并实施健康检查"></a></div><div class=article-details><header class=article-category><a href=/categories/cloud-native/>Cloud Native
</a><a href=/categories/microservice/>Microservice</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/kubernetes-springboot-health-check/>实战指南：在 Kubernetes 上部署 Spring Boot 微服务并实施健康检查</a></h2><h3 class=article-subtitle>在 Kubernetes 环境中部署 Spring Boot 微服务，并配置和健康检查，以确保微服务的可靠性和稳定性</h3></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Apr 20, 2024</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 8 分钟</time></div></footer></div></header><section class=article-content><h2 id=1-引言><a href=#1-%e5%bc%95%e8%a8%80>#</a>
1. 引言</h2><p>在云原生应用开发中，健康检查是确保微服务可靠性和稳定性的关键环节。特别是在 Kubernetes 这样的容器编排平台上，通过健康检查可以有效地监控和管理应用程序的状态，及时发现并处理潜在的故障情况，从而确保整个系统的正常运行。</p><p>而 Spring Boot 作为一种流行的 Java 微服务框架，其在 Kubernetes 上的部署和健康检查配置也是开发者们关注的焦点。本文将针对这一问题，提供一套完整的实战指南，帮助读者深入了解在 Kubernetes 环境中部署 Spring Boot 微服务并实施健康检查的步骤和方法。</p><h2 id=2-原理><a href=#2-%e5%8e%9f%e7%90%86>#</a>
2. 原理</h2><h3 id=21-kubernetes健康检查机制><a href=#21-kubernetes%e5%81%a5%e5%ba%b7%e6%a3%80%e6%9f%a5%e6%9c%ba%e5%88%b6>#</a>
2.1 Kubernetes健康检查机制</h3><p>Kubernetes中的健康检查主要使用 就绪性探针 <code>readinessProbe</code> 、存活性探针 <code>livenessProbe</code> 和启动探针 <code>startupProbe</code> 来实现，service即为负载均衡，k8s保证 service 后面的 pod 都可用，是k8s中自愈能力的主要手段，主要基于这两种探测机制，可以实现如下需求：</p><ul><li>异常实例自动剔除，并重启新实例。</li><li>多种类型探针检测，保证异常pod不接入流量。</li><li>不停机部署，更安全的滚动升级。</li></ul><h4 id=211-探针类型><a href=#211-%e6%8e%a2%e9%92%88%e7%b1%bb%e5%9e%8b>#</a>
2.1.1 探针类型</h4><p>针对运行中的容器，<code>kubelet</code> 可以选择是否执行以下三种探针，以及如何针对探测结果作出反应：</p><ul><li><strong>livenessProbe:</strong> 指示容器是否正在运行。如果存活态探测失败，则 kubelet 会杀死容器， 并且容器将根据其<code>重启策略</code>进行重启。如果容器不提供存活探针，则默认状态为 Success。</li><li><strong>readinessProbe:</strong> 指示容器是否准备好为请求提供服务。如果就绪态探测失败， 端点控制器将从与 Pod 匹配的所有服务的端点列表中删除该 Pod 的 IP 地址。初始延迟之前的就绪态的状态值默认为 <code>Failure</code>。 如果容器不提供就绪态探针，则默认状态为 <code>Success。</code></li><li><strong>startupProbe:</strong> 指示容器中的应用是否已经启动。如果提供了启动探针，则所有其他探针都会被 禁用，直到此探针成功为止。如果启动探测失败，kubelet 将杀死容器，而容器依其<code>重启策略</code>进行重启。 如果容器没有提供启动探测，则默认状态为 <code>Success。</code></li></ul><h4 id=212-探针结果><a href=#212-%e6%8e%a2%e9%92%88%e7%bb%93%e6%9e%9c>#</a>
2.1.2 探针结果</h4><p>每次探测都将获得以下三种结果之一：</p><ul><li><strong>Success（成功）:</strong> 容器通过了诊断。</li><li><strong>Failure（失败）:</strong> 容器未通过诊断。</li><li><strong>Unknown（未知）:</strong> 诊断失败，因此不会采取任何行动。</li></ul><h4 id=213-探针检查机制><a href=#213-%e6%8e%a2%e9%92%88%e6%a3%80%e6%9f%a5%e6%9c%ba%e5%88%b6>#</a>
2.1.3 探针检查机制</h4><p>使用探针来检查容器有四种不同的方法。 每个探针都必须准确定义为这四种机制中的一种：</p><ul><li><strong>exec：</strong> 在容器内执行指定命令。如果命令退出时返回码为 0 则认为诊断成功。</li><li><strong>grpc：</strong> 使用 gRPC 执行一个远程过程调用。 目标应该实现 gRPC 健康检查。 如果响应的状态是 &ldquo;SERVING&rdquo;，则认为诊断成功。</li><li><strong>httpGet：</strong> 对容器的 IP 地址上指定端口和路径执行 HTTP GET 请求。如果响应的状态码大于等于 200 且小于 400，则诊断被认为是成功的。</li><li><strong>tcpSocket：</strong> 对容器的 IP 地址上的指定端口执行 TCP 检查。如果端口打开，则诊断被认为是成功的。 如果远程系统（容器）在打开连接后立即将其关闭，这算作是健康的。</li></ul><h3 id=22-spring-boot对kubernetes容器探针的支持><a href=#22-spring-boot%e5%af%b9kubernetes%e5%ae%b9%e5%99%a8%e6%8e%a2%e9%92%88%e7%9a%84%e6%94%af%e6%8c%81>#</a>
2.2 Spring Boot对Kubernetes容器探针的支持</h3><p>Spring Boot 2.3 版本引入了容器探针功能，其中包括了 <code>/actuator/health/liveness</code> 和 <code>/actuator/health/readiness</code> 这两个健康检查路径。这些路径是为了更好地支持部署在 Kubernetes 等容器环境中的应用程序。</p><ul><li><code>/actuator/health/liveness</code> 用于存活性检查，用于确定应用程序是否仍然在运行。</li><li><code>/actuator/health/readiness</code> 用于就绪性检查，用于确定应用程序是否准备好接收流量。</li></ul><p>Spring Boot Actuator 会自动将这两个路径暴露出来，并通过它们来执行相应的健康检查。这样，当你在 Kubernetes 中部署 Spring Boot 应用程序时，Kubernetes 可以利用这些路径来确定容器是否健康和准备好接收流量。</p><p>这种集成简化了在 Kubernetes 中部署 Spring Boot 应用程序的流程，并提高了应用程序的可靠性和可用性。</p><h4 id=221-spring-boot-如何识别k8s环境><a href=#221-spring-boot-%e5%a6%82%e4%bd%95%e8%af%86%e5%88%abk8s%e7%8e%af%e5%a2%83>#</a>
2.2.1 Spring Boot 如何识别k8s环境</h4><p>Spring Boot 通过检查环境中的 <code>"*_SERVICE_HOST"</code> 和 <code>"*_SERVICE_PORT"</code> 变量来自动检测 Kubernetes 部署环境。也可以使用 <code>spring.main.cloud-platform</code> 配置属性覆盖此检测。</p><p>Spring Boot 识别到 Kubernetes 环境后，Spring Boot Actuator 会自动将<code>/actuator/health/liveness</code> 和 <code>/actuator/health/readiness</code>这两个端点暴露出来。</p><blockquote><p>小技巧：本地验证这一特性可以通过手动设置 <em>KUBERNETES_SERVICE_HOST</em> 和 <em>KUBERNETES_SERVICE_PORT</em> 这两个环境变量来开启存活和就绪检查。访问 <em>http://localhost:8080/actuator/health/liveness</em> 响应200状态码时代表已开启。</p></blockquote><h4 id=222-spring-boot-与k8s容器探针的结合><a href=#222-spring-boot-%e4%b8%8ek8s%e5%ae%b9%e5%99%a8%e6%8e%a2%e9%92%88%e7%9a%84%e7%bb%93%e5%90%88>#</a>
2.2.2 Spring Boot 与k8s容器探针的结合</h4><p>默认情况下，Spring Boot 管理应用程序可用性状态。如果部署在 Kubernetes 环境中，Actuator 会从收集“Liveness”和“Readiness”信息，并将该信息用于各类专用的 <code>HealthIndicators</code>。</p><p>Kubernetes 存活与就绪检查配置示例：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>livenessProbe</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>httpGet</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>path</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;/actuator/health/liveness&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>port</span><span class=p>:</span><span class=w> </span><span class=l>&lt;actuator-port&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>failureThreshold</span><span class=p>:</span><span class=w> </span><span class=l>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>periodSeconds</span><span class=p>:</span><span class=w> </span><span class=l>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>readinessProbe</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>httpGet</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>path</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;/actuator/health/readiness&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>port</span><span class=p>:</span><span class=w> </span><span class=l>&lt;actuator-port&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>failureThreshold</span><span class=p>:</span><span class=w> </span><span class=l>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>periodSeconds</span><span class=p>:</span><span class=w> </span><span class=l>...</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><blockquote><p><actuator-port>应设置为 actuator endpoints 的端口。它可能是 Web 服务器端口或为 Actuator 单独设置的端口。通过 &ldquo;management.server.port&rdquo; 配置指定。</p></blockquote><h4 id=223-spring-boot-生命周期与探测状态><a href=#223-spring-boot-%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e4%b8%8e%e6%8e%a2%e6%b5%8b%e7%8a%b6%e6%80%81>#</a>
2.2.3 Spring Boot 生命周期与探测状态</h4><p>Kubernetes Probes 支持的一个重要方面是它与应用程序生命周期的一致性。（应用程序的内存中内部状态）和实际探针（公开该状态）之间存在显着差异。根据应用程序生命周期的阶段，探测器可能不可用。</p><p>Spring Boot 在启动和关闭期间发布 <em>Application Events</em>，探测器可以监听此类事件并暴露 <em>AvailabilityState</em> 信息。</p><p>下表显示了AvailabilityState和HTTP连接器在不同阶段的状态。</p><p>当 Spring Boot 应用程序启动时：
<img src=/p/kubernetes-springboot-health-check/image.png width=1990 height=542 srcset="/p/kubernetes-springboot-health-check/image_hub8d9176f3a8360729b7465a357c86566_137478_480x0_resize_box_3.png 480w, /p/kubernetes-springboot-health-check/image_hub8d9176f3a8360729b7465a357c86566_137478_1024x0_resize_box_3.png 1024w" loading=lazy alt="alt text" class=gallery-image data-flex-grow=367 data-flex-basis=881px></p><p>当 Spring Boot 应用程序 关闭时:
<img src=/p/kubernetes-springboot-health-check/image-1.png width=1948 height=498 srcset="/p/kubernetes-springboot-health-check/image-1_hu05efa868d7dab2ee38f7d14b4f8433cc_122400_480x0_resize_box_3.png 480w, /p/kubernetes-springboot-health-check/image-1_hu05efa868d7dab2ee38f7d14b4f8433cc_122400_1024x0_resize_box_3.png 1024w" loading=lazy alt="alt text" class=gallery-image data-flex-grow=391 data-flex-basis=938px></p><h2 id=3-准备工作><a href=#3-%e5%87%86%e5%a4%87%e5%b7%a5%e4%bd%9c>#</a>
3. 准备工作</h2><p>在开始部署 Spring Boot 微服务到 Kubernetes 之前，我们首先需要准备好以下工作环境和所需工具：</p><ul><li>一个运行正常的 Kubernetes 集群，可以是本地的 minikube 集群或者云上的托管 Kubernetes 服务。</li><li>已经构建好的 Spring Boot 应用程序的 Docker 镜像，可以通过 Dockerfile 构建，或者使用 Maven 插件和 Docker 插件直接构建。</li><li>Kubernetes 部署和服务资源的 YAML 配置文件，用于定义应用程序的部署、服务和健康检查配置。</li></ul><h2 id=4-在-kubernetes-中部署-spring-boot-微服务><a href=#4-%e5%9c%a8-kubernetes-%e4%b8%ad%e9%83%a8%e7%bd%b2-spring-boot-%e5%be%ae%e6%9c%8d%e5%8a%a1>#</a>
4. 在 Kubernetes 中部署 Spring Boot 微服务</h2><p>在准备工作完成之后，我们就可以开始在 Kubernetes 中部署 Spring Boot 微服务了。首先，我们需要创建一个 Kubernetes 部署资源，用来描述应用程序的容器镜像、副本数等信息。接下来，我们再创建一个 Kubernetes 服务资源，用来暴露应用程序的网络端口，以便其他服务可以访问到该应用程序。让我们一起来看看具体的操作步骤：</p><ul><li><strong>创建 Kubernetes 部署资源：</strong> 在 Kubernetes 中，部署资源用于定义应用程序的部署策略和运行配置。我们可以通过一个 YAML 配置文件来创建一个部署资源，示例配置文件如下所示：</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>apps/v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Deployment</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>my-springboot-app</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>replicas</span><span class=p>:</span><span class=w> </span><span class=m>3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>selector</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>matchLabels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>my-springboot-app</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>template</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>labels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>my-springboot-app</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>containers</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>my-springboot-app</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>your-docker-registry/my-springboot-app:latest</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>- <span class=nt>containerPort</span><span class=p>:</span><span class=w> </span><span class=m>8080</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>在这个示例中，我们定义了一个名为 <code>my-springboot-app</code> 的 Deployment 资源，指定了要运行的容器镜像和副本数，并暴露了容器的 8080 端口。</p><ul><li><strong>创建 Kubernetes 服务资源：</strong> 在 Kubernetes 中，服务资源用于定义应用程序的网络访问方式和负载均衡策略。我们同样可以通过一个 YAML 配置文件来创建一个服务资源，示例配置文件如下所示：</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Service</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>my-springboot-app-service</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>selector</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>app</span><span class=p>:</span><span class=w> </span><span class=l>my-springboot-app</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>protocol</span><span class=p>:</span><span class=w> </span><span class=l>TCP</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>port</span><span class=p>:</span><span class=w> </span><span class=m>80</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>targetPort</span><span class=p>:</span><span class=w> </span><span class=m>8080</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>LoadBalancer</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>在这个示例中，我们定义了一个名为 <code>my-springboot-app-service</code> 的 Service 资源，通过 <code>selector</code> 字段指定了要负载均衡的 Deployment，并将容器的 8080 端口映射到了服务的 80 端口。</p><p>通过上述步骤，我们就可以成功地在 Kubernetes 中部署了一个运行 Spring Boot 微服务的容器应用程序。接下来，我们将重点关注如何配置和实施健康检查，以确保应用程序的稳定性和可靠性。</p><h2 id=5-配置健康检查><a href=#5-%e9%85%8d%e7%bd%ae%e5%81%a5%e5%ba%b7%e6%a3%80%e6%9f%a5>#</a>
5. 配置健康检查</h2><p>在 Kubernetes 中，健康检查通过 liveness 探针和 readiness 探针来实现。liveness 探针用于检查应用程序是否处于运行状态，而 readiness 探针用于检查应用程序是否已准备好接收流量。下面我们将分别介绍如何在 Spring Boot 应用程序中实现这两种探针，并在 Kubernetes 中进行配置。</p><ul><li><strong>实现 liveness 探针：</strong> 在 Spring Boot 应用程序中实现 liveness 探针非常简单，我们只需创建一个端点接口，用于检查应用程序的运行状态即可。例如，我们可以创建一个 <code>/actuator/health</code> 的端点，用于返回应用程序的健康状态。在 Spring Boot 应用程序中，我们可以通过 Spring Boot Actuator 模块来实现这一功能。在 <code>application.properties</code> 配置文件中添加以下配置：</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-properties data-lang=properties><span class=line><span class=cl><span class=na>management.endpoint.health.enabled</span><span class=o>=</span><span class=s>true</span>
</span></span><span class=line><span class=cl><span class=na>management.endpoint.health.probes.enabled</span><span class=o>=</span><span class=s>true</span>
</span></span><span class=line><span class=cl><span class=na>management.endpoints.web.exposure.include</span><span class=o>=</span><span class=s>health</span>
</span></span></code></pre></td></tr></table></div></div><p>然后，我们就可以访问 <code>/actuator/health</code> 端点来检查应用程序的运行状态了。</p><ul><li><strong>实现 readiness 探针：</strong> 与 liveness 探针类似，实现 readiness 探针也很简单。我们可以创建一个类似的端点接口，用于检查应用程序是否已准备好接收流量。例如，我们可以创建一个 <code>/actuator/readiness</code> 的端点，用于返回应用程序的就绪状态。同样地，我们可以通过 Spring Boot Actuator 模块来实现这一功能，在 <code>application.properties</code> 配置文件中添加以下配置：</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-properties data-lang=properties><span class=line><span class=cl><span class=na>management.endpoint.health.enabled</span><span class=o>=</span><span class=s>true</span>
</span></span><span class=line><span class=cl><span class=na>management.endpoint.health.probes.enabled</span><span class=o>=</span><span class=s>true</span>
</span></span><span class=line><span class=cl><span class=na>management.endpoint.health.probes.include</span><span class=o>=</span><span class=s>readiness</span>
</span></span></code></pre></td></tr></table></div></div><p>然后，我们就可以访问 <code>/actuator/readiness</code> 端点来检查应用程序的就绪状态了。</p><ul><li><strong>在 Kubernetes 中配置健康检查：</strong> 在 Kubernetes 的部署配置文件中，我们可以通过 <code>livenessProbe</code> 和 <code>readinessProbe</code> 字段来定义容器的健康检查。例如，我们可以使用以下配置来定义一个 liveness 探针：</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>livenessProbe</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>httpGet</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>path</span><span class=p>:</span><span class=w> </span><span class=l>/actuator/health</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>port</span><span class=p>:</span><span class=w> </span><span class=m>8080</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>initialDelaySeconds</span><span class=p>:</span><span class=w> </span><span class=m>30</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>periodSeconds</span><span class=p>:</span><span class=w> </span><span class=m>10</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>这个配置将会在容器启动后等待 30 秒后开始进行 liveness 探测，每隔 10 秒进行一次探测，检查 <code>/actuator/health</code> 端点的返回状态。</p><p>类似地，我们也可以使用类似的配置来定义一个 readiness 探针。</p><p>通过上述步骤，我们就成功地在 Spring Boot 应用程序中实现了 liveness 探针和 readiness 探针，并在 Kubernetes 中进行了相应的配置。接下来，我们将进行实战演练，验证健康检查的配置是否生效，以及如何使用 kubectl 命令来查看应用程序的健康状态。</p><h2 id=6-验证><a href=#6-%e9%aa%8c%e8%af%81>#</a>
6. 验证</h2><p>在本节中，我们将演示如何使用 kubectl 命令来查看应用程序的健康状态，并验证健康检查的配置是否生效。</p><ul><li><strong>查看 liveness 探针状态：</strong> 使用以下命令可以查看应用程序的 liveness 探针状态：</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>kubectl describe pod &lt;pod_name&gt;
</span></span></code></pre></td></tr></table></div></div><p>该命令将输出包含容器状态和事件的详细信息。在输出结果中，可以找到有关 liveness 探针的相关信息，例如探针的执行结果和最后一次执行的时间戳。</p><ul><li><strong>验证 readiness 探针状态：</strong> 使用以下命令可以验证应用程序的 readiness 探针状态：</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>kubectl get pods
</span></span></code></pre></td></tr></table></div></div><p>该命令将列出所有运行中的 Pod，并显示它们的状态。通过观察 READY 列中的值，可以了解到每个 Pod 是否已准备好接收流量。</p><p>通过上述命令，我们可以轻松地验证健康检查的配置是否生效，并了解应用程序的健康状态。如果出现健康检查失败或异常的情况，我们还可以使用 kubectl 命令来进行故障排除和调试，以找出问题的根源并及时处理。</p><h2 id=7-总结><a href=#7-%e6%80%bb%e7%bb%93>#</a>
7. 总结</h2><p>通过本文的实战指南，我们深入探讨了在 Kubernetes 环境中部署 Spring Boot 微服务并实施健康检查的方法和步骤。我们首先介绍了健康检查的概念和重要性，然后详细讲解了如何在 Spring Boot 应用程序中实现 liveness 探针和 readiness 探针，并在 Kubernetes 中进行配置。最后，我们进行了实战演练，验证了健康检查的配置是否生效，并了解了如何使用 kubectl 命令来查看应用程序的健康状态和进行故障排除。</p><p>通过正确地配置和实施健康检查，我们可以有效地监控和管理应用程序的状态，及时发现并处理潜在的故障情况，从而确保整个系统的正常运行。希望本文对您理解和掌握云原生健康检查的实践技巧有所帮助，也欢迎您在实际应用中进行进一步的尝试和探索。</p><h2 id=参考资料><a href=#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99>#</a>
参考资料</h2><ul><li><a class=link href=https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#container-probes target=_blank rel=noopener>https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#container-probes</a></li><li><a class=link href=https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes target=_blank rel=noopener>https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes</a></li><li><a class=link href=https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html#actuator.endpoints.kubernetes-probes target=_blank rel=noopener>https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html#actuator.endpoints.kubernetes-probes</a></li><li><a class=link href=https://docs.spring.io/spring-boot/docs/current/reference/html/deployment.html#deployment.cloud.kubernetes.container-lifecycle target=_blank rel=noopener>https://docs.spring.io/spring-boot/docs/current/reference/html/deployment.html#deployment.cloud.kubernetes.container-lifecycle</a></li><li><a class=link href=https://docs.spring.io/spring-boot/docs/current/reference/html/web.html#web.graceful-shutdown target=_blank rel=noopener>https://docs.spring.io/spring-boot/docs/current/reference/html/web.html#web.graceful-shutdown</a></li></ul></section><footer class=article-footer><section class=article-tags><a href=/tags/cloud-native/>Cloud Native</a>
<a href=/tags/kubernetes/>Kubernetes</a>
<a href=/tags/spring-boot/>Spring Boot</a>
<a href=/tags/%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5/>健康检查</a></section><section class=article-lastmod><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>最后更新于 Apr 20, 2024 21:00 UTC</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article class=has-image><a href=/p/ip-protocal-migration/><div class=article-image><img src=/p/ip-protocal-migration/cover.c514d916917173a48a42e0114b469961_hud7e36f7e20e71be184458283bdae4646_55974_250x150_fill_q75_box_smart1.jpg width=250 height=150 loading=lazy alt="Featured image of post Spring Cloud应用如何平滑迁移至IPv6?" data-key=ip-protocal-migration data-hash="md5-xRTZFpFxc6SKQuARS0aZYQ=="></div><div class=article-details><h2 class=article-title>Spring Cloud应用如何平滑迁移至IPv6?</h2></div></a></article></div></div></aside><div class=disqus-container><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//xiuwei.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{typeof DISQUS=="object"&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2024 哈皮的自言自语</section><section class=powerby>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 构建<br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.25.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script><script>document.querySelectorAll(".powerby").forEach(e=>{e.style.display="none"})</script></body></html>